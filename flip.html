<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Flipbook Viewer</title>

  <!-- 전역 설정: 반드시 먼저 -->
  <script src="./config.js"></script>
  <!-- PageFlip (UMD: window.St) -->
  <script src="./vendor/pageflip/page-flip.browser.js"></script>

  <style>
    :root { --bg:#0b0b10; --fg:#eaeaea; --muted:#9aa0a6; --ring:#222735; }
    html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);}
    header{
      display:flex;align-items:center;gap:10px;padding:10px 12px;
      border-bottom:1px solid var(--ring);background:#0d1018;position:sticky;top:0;z-index:10
    }
    header a{color:#9ab4ff;text-decoration:none}
    .bar{margin-left:auto;display:flex;gap:8px}
    .btn{background:#192034;border:1px solid var(--ring);color:#eaeaea;padding:8px 10px;border-radius:10px;font-size:12px}
    .btn:hover{border-color:#3b82f6}
    /* 여백 최소화 */
    #stageWrap{height:calc(100vh - 52px);display:grid;place-items:center;overflow:auto}
    /* 컨테이너를 화면 가득 */
    #stage{
      width:96vw;max-width:1400px;height:calc(100vh - 72px);
      background:#0f1420;border:1px solid var(--ring);border-radius:12px;
      box-shadow:0 10px 40px rgba(0,0,0,.35)
    }
    /* Flip 내부 페이지 */
    .page{background:#fff;display:flex;align-items:center;justify-content:center}
    .page img{width:100%;height:100%;object-fit:contain;display:block}
    /* 로더 */
    #loader{text-align:center;color:var(--muted);padding:10px 0}
    #progress{height:6px;background:#111624;border-radius:6px;overflow:hidden;margin:6px auto;width:240px}
    #progress>div{height:100%;background:#3b82f6;width:0%}
    #error{color:#ff8686;text-align:center;padding:12px;display:none}
  </style>
</head>
<body>
  <header>
    <a href="./">← 목록으로</a>
    <strong id="title" style="white-space:nowrap;overflow:hidden;text-overflow:ellipsis;"></strong>
    <div class="bar">
      <button class="btn" id="prevBtn">이전</button>
      <button class="btn" id="nextBtn">다음</button>
      <button class="btn" id="zoomOut">-</button>
      <button class="btn" id="zoomIn">+</button>
      <a class="btn" id="download" target="_blank" rel="noopener">다운로드</a>
      <!-- 원본 PDF 보기(기존 뷰어) 옵션 -->
      <a class="btn" id="openOriginal" target="_blank" rel="noopener">원본 보기</a>
    </div>
  </header>

  <div id="stageWrap">
    <div id="stage"></div>
    <div id="loader">
      <div>페이지 렌더링 중… <span id="pct">0%</span></div>
      <div id="progress"><div></div></div>
    </div>
    <div id="error"></div>
  </div>

  <!-- PDF.js v4 (ESM) + 렌더 로직 -->
  <script type="module">
    import * as pdfjsLib from './vendor/pdfjs/pdf.min.mjs';
    pdfjsLib.GlobalWorkerOptions.workerSrc = './vendor/pdfjs/pdf.worker.min.mjs';

    const showErr = (msg) => {
      console.error(msg);
      const el = document.getElementById('error');
      el.style.display = 'block';
      el.textContent = '로드 실패: ' + msg;
    };

    try {
      // 1) 파라미터/설정
      const qs   = new URLSearchParams(location.search);
      const id   = qs.get('id');
      const name = qs.get('name') || 'PDF 문서';
      document.getElementById('title').textContent = name;

      if (!id) throw new Error('URL 파라미터 id가 없습니다.');
      if (!window.DRIVE_CONFIG || !window.DRIVE_CONFIG.API_KEY)
        throw new Error('config.js의 API_KEY를 찾을 수 없습니다.');
      const API_KEY = window.DRIVE_CONFIG.API_KEY;

      // 파일 URL
      const fileUrl = `https://www.googleapis.com/drive/v3/files/${encodeURIComponent(id)}?alt=media&key=${encodeURIComponent(API_KEY)}`;
      document.getElementById('download').href = fileUrl;
      document.getElementById('openOriginal').href =
        `./viewer.html?id=${encodeURIComponent(id)}&name=${encodeURIComponent(name)}`;

      // 2) PDF 가져오기
      const res = await fetch(fileUrl, { mode: 'cors' });
      if (!res.ok) throw new Error(`Drive fetch 실패: ${res.status} ${res.statusText}`);
      const buf = await res.arrayBuffer();

      // 3) PDF 열기
      const loadingTask = pdfjsLib.getDocument({
        data: buf,
        disableAutoFetch: true,
        disableStream: true,
        useSystemFonts: true,
      });
      const pdf = await loadingTask.promise;

      // 4) Flipbook 초기화(여백 최소, 뷰포트 가득)
      const stage = document.getElementById('stage');
      const pageFlip = new window.St.PageFlip(stage, {
        size: 'stretch',
        width:  700,      // 초기 기준값(실제는 stretch + 아래 스케일 계산)
        height: 1000,
        drawShadow: true,
        flippingTime: 350,
        usePortrait: false,
        showCover: true,
        mobileScrollSupport: true,
        maxShadowOpacity: 0.2,
        startZIndex: 3
      });

      // 컨트롤
      document.getElementById('prevBtn').onclick = () => pageFlip.flipPrev();
      document.getElementById('nextBtn').onclick = () => pageFlip.flipNext();
      let zoom = 1;
      const applyZoom = () => {
        stage.style.transform = `scale(${zoom})`;
        stage.style.transformOrigin = 'center top';
      };
      document.getElementById('zoomIn').onclick  = () => { zoom = Math.min(2.5, zoom + 0.1); applyZoom(); };
      document.getElementById('zoomOut').onclick = () => { zoom = Math.max(0.7, zoom - 0.1); applyZoom(); };

      // 5) 해상도 계산: 한 페이지가 stage 너비의 절반을 차지하도록, DPR 반영
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      const stageW = () => stage.clientWidth;  // spread 기준
      // scale 계산 함수: pdf page viewport(1배) 기준 한 페이지 폭을 컨테이너 절반에 맞춤
      const calcScale = (pageViewportWidth) => {
        const singlePageTarget = stageW() / 2;               // 펼친면(두 페이지) 기준
        const base = singlePageTarget / pageViewportWidth;   // 화면 너비에 맞춤
        const hiDPI = Math.min(2.0, dpr);                    // 과도한 초고해상도 제한(성능/메모리)
        return Math.max(1.0, base * hiDPI);                  // 최소 1배
      };

      // 6) 페이지 렌더
      const total = pdf.numPages;
      const pctEl = document.getElementById('pct');
      const barEl = document.querySelector('#progress > div');
      const pages = [];

      for (let p = 1; p <= total; p++) {
        const page = await pdf.getPage(p);

        // 원본 뷰포트(1배)로 페이지 너비 파악 → stage에 맞춘 스케일 계산
        const vp1 = page.getViewport({ scale: 1 });
        const scale = calcScale(vp1.width);

        const viewport = page.getViewport({ scale });
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        // 캔버스 크기는 실제 픽셀단위(선명하게)
        canvas.width  = Math.floor(viewport.width);
        canvas.height = Math.floor(viewport.height);

        await page.render({ canvasContext: ctx, viewport }).promise;
        pages.push(canvas.toDataURL('image/jpeg', 0.95)); // 고품질 JPEG

        const pct = Math.round((p / total) * 100);
        pctEl.textContent = pct + '%';
        barEl.style.width = pct + '%';
      }

      // 7) Flipbook에 로드 (URL 배열)
      pageFlip.loadFromImages(pages);
      pageFlip.on('init', () => {
        const loader = document.getElementById('loader');
        if (loader) loader.style.display = 'none';
      });

      // 창 크기 변경 시 scale 재계산(선택사항: 필요시 재렌더)
      // 여기서는 간단히 stage만 확대/축소(다시 렌더는 비용 큼)
      window.addEventListener('resize', () => {
        // 필요하면: 다시 렌더 로직을 호출하여 pages 갱신하도록 확장 가능
      });

    } catch (e) {
      showErr(e?.message || String(e));
    }
  </script>
</body>
</html>
